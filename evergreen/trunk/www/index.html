<!--#set var="PAGE_TITLE" value="Evergreen" -->
<!--#set var="HUMAN_NAME" value="Evergreen" -->
<!--#set var="SHORT_DIST_NAME" value="evergreen" -->
<!--#set var="LONG_DIST_NAME" value="org.jessies.evergreen" -->

<!--#include virtual="/salma-hayek/header.html" -->

<h1>Evergreen</h1>

<p><strong>Evergreen (formerly "Edit") is a cross-platform GPL development environment that tries to be lightweight and language-agnostic yet functional.</strong>

<p>Evergreen started as a project to reimplement Rob Pike's <a href="http://plan9.bell-labs.com/sys/doc/acme.html">acme</a> editor in Java, so I could use it on Unix and Windows.
(I'd got used to it at university, using Plan 9.)
Eventually, my editor diverged and today probably represents my personality quite closely; in particular, if the computer <i>can</i> do the right thing, it <i>must</i>.
I certainly shouldn't have to.

<!--#include virtual="/salma-hayek/navigation.html" -->

<h2><a name="features">Features</a></h2>

<ul>
<li><p><strong>Ubiquitous Regular Expressions</strong> - Programmers know regular expressions, and yet their graphical tools don't use make much use of them.
Evergreen does.
Anywhere it's asking you to type something, it's probably expecting a regular expression: full Perl/Java regular expressions in find, in find/replace, in find in files (as you'd expect), but also in the open dialog. Evergreen uses "smart case" regular expressions, too, where an all-lowercase regular expression is assumed to be case-insensitive. You can use <tt>(?-i)</tt> and <tt>(?i)</tt> to explicitly turn case-sensitivity on and off.

<li><p><strong>Open Files Quicker</strong> - Evergreen indexes your project, so you don't have to remember where files are.
Or what case your co-worker used ("Hyperlink" or "HyperLink"?).
Just a substring or regular expression that matches what you want.
Evergreen updates a list of the matching files as you type (like iTunes):

<p align="center"><img src="open-quickly.png" width="591" height="322" alt="Open Quickly dialog">

<li><p><strong>Find in Files</strong> - You can also search for files to open based on their content.
Evergreen shows a tree of matches, representing the directory hierarchy.
Files containing definitions are marked as such.
Searching is done in parallel to take advantage of modern multi-core machines.
Search results are automatically updated if anything changes:

<p align="center"><img src="find-in-files.png" width="723" height="502" alt="Find in Files dialog">

<li><p><strong>Find</strong> - You have a fast computer, yet the 'find' function in other editors doesn't take full advantage of that fact.
Evergreen, like <tt>less(1)</tt>, highlights all the matches, whether you search with C-F or clicked on a match in the "Find in Files" dialog.
Better still, Evergreen highlights all the matches as you type, so you know when you've typed enough (or too much, if you suddenly see there are no matches).
Evergreen also lets you move backwards as easily as forwards through the matches: just use C-D to move backwards and C-G to move forwards, both conveniently placed around C-F, which defaults to searching for the currently-selected word.
All of this comes together for fluid one-handed searching.
Finally, Evergreen uses marks next to the scroll bar to give you contextual information about how many matches there are, and how they're clustered.
You can click on a mark to skip a large clump of uninteresting matches, if you wish:

<p align="center"><img src="find.png" width="748" height="185" alt="Highlighted find matches">

<li><p><strong>Spelling Checking for Source Code</strong> - Not only does Evergreen check your spelling as you type, it understands CamelCase words aren't single-word spelling mistakes but compounds of correctly spelled words.
In this example, the identifiers have been checked too:

<p align="center"><img src="spelling.png" width="433" height="159" alt="Spelling checking of code">

<li><p><strong>Exuberant Ctags Support</strong> - Evergreen uses <a href="http://ctags.sourceforge.net/">Exuberant Ctags</a> (if installed) to understand the structure of your file.
The symbols in the current file are shown as a tree preserving their hierarchy.
You can click on an item in the tree to go to the corresponding part of the file.
Conversely, as you edit, the item in the tree corresponding to the current caret position is always highlighted.

<p align="center">
<img src="tags-panel.png" width="197" height="120" alt="Tags support">

<p>The little icons tell you what kind of symbol you're dealing with.
Classes, methods, and fields are circles, squares, and triangles respectively.
An icon's color denotes the symbol's accessibility.
Public, protected, private, and unknown accessibilities are shown as green, orange, red, and gray respectively.
Icons for abstract classes or methods are hollow.
Public static symbols are in bold.
(Obviously, not all possibilities are available in all languages.)

<li><p><strong>Bug Database Links</strong> - References to bugs in your (or others') bug databases are automatically recognized and turned into hyperlinks:

<p align="center">
<img src="bug-links.png" width="442" height="261" alt="Bug database links">

<li><p><strong>Find/Replace</strong> - Find/replace functionality in other editors has a habit of being awkward in use.
How much better to be able to see all the changes at once, with the results of the substitutions? Hovering over a match shows the captured groups in a tool tip, so you can check your capturing is as you intended.

<p align="center"><img src="find-replace.png" width="706" height="530" alt="Find and replace">

<p>(An open question is whether we wouldn't be even more comfortable with something more like the output from <tt>diff&nbsp;-u</tt>.)

<li><p><strong>Workspaces</strong> - You can work on multiple projects at once, with each "workspace" getting its own tab in the overall UI.
<p>Workspaces are important.
You probably want one for each project you're working on; if you're looking for "session" functionality, this is it.

<p>If a workspace looks like a project (i.e. has a Makefile or is under revision control), the files will be indexed, so you probably want the root of your workspaces to be the directories with the top-level build instructions. There's no reason you can't create an empty Makefile as a hint to Evergreen if you want a workspace's root to be a directory that contains a collection of related projects, or it can sometimes be useful to create a simple Makefile to build all the contained projects. Evergreen doesn't look at Makefile content, so it doesn't care.

<p>Workspaces are automatically saved when you quit and restored when you restart Evergreen.

<li><p><strong>Auto-Indent</strong> - Evergreen will automatically help you format your code in K&amp;R, Linux kernel, or Sun's Java style.
If you want to manually break long lines or use an indenting style too far removed from these, you're likely to face difficulties as it continues to try to "correct" your style.
Ken Arnold's <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=74230">thoughts on coding style</a> explain why this is usually a counter-productive degree of freedom.
What you gain from accepting Evergreen's style (which shouldn't be a problem for most programmers) is that Evergreen will do most of the formatting for you.
Even correcting stuff you paste in.

<li><p><strong>Watermarks</strong> - Each document has a watermark, used to show you if you're looking at a read-only file, or a file that has been updated on disk since it was last read in.

<li><p><strong>Building</strong> - Evergreen defers to make(1) or ant(1) to actually build your project, and will search upward from the directory containing the focused file looking for a makefile.

<li><p><strong>Patches</strong> - If you choose a potentially destructive action such as "Revert to Saved", you're shown a colored patch and given a chance to change your mind.
(Not only that, it's a useful way to see how a machine-generated file is changing as you work on the generator.
Just keep running the script and reverting to the latest version of the generated file.)

<li><p><strong>"Compare Selection and Clipboard..."</strong> - Shows you a patch comparing the currently-selected text and the text on the clipboard.
This is useful when you're looking at two seemingly duplicate chunks of code and want to know what, if any, differences there are between the two.

<li><p><strong>Language awareness</strong> - Coloring and intelligent indentation of C++, Java, Perl, Ruby, and others.

<li><p><strong>Custom text component</strong> - We gave up on <code>JTextPane</code> because of its poor performance, and we gave up on <code>JTextArea</code> because of its poor functionality.
Unlike many other editors with their own text components, ours was explicitly designed to be useful elsewhere.
It's interface is broadly similar to <code>JTextArea</code> so it's easy to use in your own programs if you get used to any of the great functionality.

</ul>

<h2><a name="configuration">Configuration</a></h2>

<h3>Restricting Evergreen's Indexing Activity</h3>
<p>If Evergreen finds an executable called <tt>echo-local-non-source-directory-pattern</tt> on your path, it will be run at start-up.
The output is interpreted as a regular expression pattern per line describing the names of directories that Evergreen shouldn't scan when indexing your workspace.
Evergreen already knows about most version control systems and about the autotools directories, so you shouldn't have to worry about those.
Evergreen also assumes that there's nothing interesting in "dot directories" (directories whose names begin with a ".").
The ability to add custom directory patterns is useful in a variety of cases.
The most common example is when your object files (or your test data, or whatever it is you don't want Evergreen to index/search) live under your workspace root but are segregated into directories with distinctive names.
You should make sure Evergreen knows the name of the directories containing such files, for performance.

<p>If you can't help Evergreen out&nbsp;&ndash; perhaps because keep your object files in the same directory as your source&nbsp;&ndash; Evergreen will ignore each file one by one.
This has a similar end result, but it's much less efficient, and it's your time you're wasting.

<p>Evergreen already knows about most common build artifacts (object files and their friends) and recognizes them by their filename extension.
If you have an unusual one (and it isn't already hidden in a directory that Evergreen won't scan) you can add the extension to Evergreen's list in the GUI preferences dialog.

<p>If you think the extension is a common one that Evergreen should automatically ignore, please let us know so that we can add it to the built-in list so everyone benefits.

<h3>Adding Custom Lint Checkers</h3>
<p>If you dislike Evergreen's default choice of lint checker for a given language, or have a lint checker for a language Evergreen doesn't have a default for, you can override or supplement Evergreen's choices.
Say you have a C++ static analysis tool you want Evergreen to use.
Edit the <tt>~/.e.edit.Edit/edit.properties</tt> file and add a line <tt>C++.lintChecker=cpplint</tt> (including any arguments).
The bit before the "." is the name shown in the File Properties dialog.
If lint checking for HTML weren't built in, for example, the current behavior could be specified with <tt>XML.lintChecker=tidy -qe</tt>.
Note that we use the file type mode's name ("XML") rather than, say, the specific file extension or specific dialect.

<p>We hope to replace this with a GUI for filetype-specific configuration in the future.

<!--#include virtual="/salma-hayek/downloads.html" -->

<!--#include virtual="/salma-hayek/footer.html" -->
