<html>
<head>
<title>Evergreen</title>
<link rel="stylesheet" type="text/css" href="/salma-hayek/styles.css" />
</head>
<body>

<h1>Evergreen</h1>

<p><strong>Evergreen (formerly "Edit") is a GPL development environment that tries to be lightweight
and language-agnostic yet functional.</strong>

<h2>Why another editor?</h2>

<p>You can be forgiven for wondering why anyone would write another editor.
There are plenty out there. Surely one fits?

<p>Evergreen started as a project to reimplement Rob Pike's
<a href="http://plan9.bell-labs.com/sys/doc/acme/acme.html">acme</a>
editor in Java, so I could use it on Unix and Windows. (I'd got used
to it at university, using Plan 9.) Eventually, my editor diverged and
today probably represents my personality quite closely; in particular,
if the computer <i>can</i> do something, it <i>must</i>. I certainly
shouldn't have to.

<h2>What's so great about Evergreen?</h2>

<h3>Ubiquitous regular expressions</h3>

<p>Programmers know regular expressions. And yet their graphical tools
don't use make much use of them. Evergreen does. Anywhere it's asking you to
type something, it's probably expecting a regular expression: full Perl/Java
regular expressions in find, in find/replace, in find in files (as you'd
expect), but also in the open dialog.

<h3>The best open dialog</h3>

<p>Evergreen indexes your project, so you don't have to remember where files
are. Or what case your co-worker used ("Hyperlink" or "HyperLink"?). Just
a substring or regular expression that matches what you want. Evergreen updates
a list of the matching files as you type (like iTunes):

<div align="center">
<img src="open-quickly.png" width="620" height="322">
</div>

<p>You can also search for files to open based on their content.

<h3>The best find</h3>

<p>You have a fast computer, yet the 'find' function in other editors
doesn't take advantage of that fact. Evergreen, like <tt>less(1)</tt>, highlights
all the matches.
Better still, Evergreen does so as you type, lets you move backwards as easily as
forwards through the matches, and shows you next to the scroll bar where the
other matches are:

<div align="center">
<img src="find.png" width="748" height="185">
</div>

<h3>The best spelling checking</h3>

<p>Not only does Evergreen check your spelling as you type, it understands
CamelCase words aren't single-word spelling mistakes but compounds of
correctly spelled words. In this example, the identifiers have been checked
too:

<div align="center">
<img src="spelling.png" width="433" height="159">
</div>

<h3>The best <tt>ctags</tt> support</h3>

<p>Evergreen uses <a href="http://ctags.sourceforge.net/">Exuberant ctags</a>
(if installed) to understand the structure of your file. You
can click on a tag to go to that point in the file, and the tag
corresponding to the current caret position is always highlighted.

<p>Classes, methods and fields are easily
distinguished by shape; accessibility is denoted by color. Static members
are in bold.

<div align="center">
<img src="tags-panel.png" width="197" height="120">
</div>

<h3>Links to bug databases</h3>

<p>References to bugs in your (or others') bug databases are automatically
recognized and turned into hyperlinks:

<div align="center">
<img src="bug-links.png" width="442" height="261">
</div>

<h3>The best find/replace</h3>

<p>Find/replace functionality in other editors
has a habit of being awkward in use. How much
better to be able to see all the changes at once, with the results of the
substitutions?

<div align="center">
<img src="find-replace.png" width="706" height="530">
</div>

<p>(An open question is whether we wouldn't be even more comfortable with
something more like the output from <tt>diff&nbsp;-u</tt>.)

<h3>Other features</h3>

<p><b>Workspaces</b> You can work on multiple projects at once, with each "workspace" getting its
own tab in the overall UI.

<p><b>Watermarks</b> Each document has a watermark, used to show you if you're looking at a
read-only file, or a file that has been updated on disk since it was last read
in.

<p><b>Building</b> Evergreen defers to make(1) or ant(1) to actually build your project, and will search upward from the directory containing the focused file looking for a makefile.

<p><b>Patches</b> If you choose a potentially destructive action such as "Revert to Saved",
you're shown a colored patch and given a chance to change your mind. (Not only
that, it's a useful way to see how a machine-generated file is changing as
you work on the generator. Just keep running the script and reverting to the
latest version of the generated file.)

<p>"Compare Selection and Clipboard..." shows you a patch comparing the
currently-selected text and the text on the clipboard. This is useful when
you're looking at two seemingly duplicate chunks of code and want to know
what, if any, differences there are between the two.

<p><b>Language awareness</b> Coloring and intelligent indentation of C++, Java, Perl, and Ruby.

<p><b>Custom text component</b> We gave up on <code>JTextPane</code> because of its poor performance, and
we gave up on <code>JTextArea</code> because of its poor functionality. Unlike
many other editors with their own text components, ours was explicitly designed
to be useful elsewhere. It's interface is broadly similar to
<code>JTextArea</code> so it's easy to use in your own programs if you get
used to any of the great functionality.

<h2>Downloads</h2>

<p>For Ubuntu and other Debian-based Linux distributions, there's <a href="evergreen.deb">evergreen.deb</a> which will add Evergreen to your GNOME applications menu. (For command-line or non-GNOME users, there's /usr/bin/evergreen.)

<p>For Windows, there's <a href="Evergreen.msi">a Windows installer</a> which requires that you've already installed Cygwin, including Ruby, yourself but is otherwise complete and leaves you with an Evergreen icon on your desktop.

<p>We have more information about <a href="/salma-hayek/cygwin-setup.html">setting up Cygwin</a>.

<p>(Why did we choose Cygwin?
It may well be that there's no good reason for Evergreen to require Cygwin.
There's a good reason for <a href="../terminator/">Terminator</a> to use Cygwin and Evergreen shares much of its installation and invocation infrastructure with Terminator.)

<p>If you don't have Exuberant ctags as the first "ctags" on your path, you'll see an error like "Is Exuberant ctags installed and on your path? There was an error reading the tags: The tags file didn't have a valid header.". Users of Mac OS and Solaris can get our pre-built binaries of <a href="../3rdParty/ctags-5.5.4-darwin-ppc">ctags-5.5.4-darwin-ppc</a> or <a href="../3rdParty/ctags-5.5.4-solaris-amd64">ctags-5.5.4-solaris-amd64</a>, or can build their own.

<p>Otherwise, see <a href="#building-from-source">Building from source</a> on this page.

<p>The <a href="ChangeLog.html">ChangeLog</a> is available separately.

<h2>Notes on using Evergreen</h2>

<p>Workspaces are important. You probably want one for each project you're working on. If a workspace looks like a project (i.e. has a Makefile or is under revision control), the files will be indexed. So you probably want the root of your workspaces to be the directories with the top-level makefiles.

<p>Learn to live with Evergreen's idea of code formatting. If you find this hard to swallow, read <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=74230">Ken Arnold's thoughts on coding style</a> first. What you gain from accepting Evergreen's style (which shouldn't be a problem for Java programmers, because it's pretty much expecting that in all the C family) is that Evergreen will do the formatting for you. Even correcting stuff you paste in.

<a name="building-from-source">
<h2>Building from source</h2>
</a>

<p>There's a source distribution (<a href="Evergreen.tgz">Evergreen.tgz</a>),
and you'll also need the source to the library it uses (<a href="../salma-hayek/salma-hayek.tgz">salma-hayek.tgz</a>).

<p>The <a href="../salma-hayek/index.html#building-from-source">hints for building</a> are the same for all our projects.

<!--#include virtual="/salma-hayek/footer.html" -->
</body>
</html>
