#!/usr/bin/ruby -w

require "fileutils.rb"
require "pathname.rb"

# Cope with symbolic links to this script.
project_root = Pathname.new(__FILE__).realpath().dirname().dirname()
salma_hayek = Pathname.new("#{project_root}/../salma-hayek").realpath()
require "#{salma_hayek}/bin/target-os.rb"
require "#{salma_hayek}/bin/invoke-java.rb"

HOME = ENV["HOME"]

ENV["EDIT_HOME"] = project_root

TARGET_OS = target_os()

edit_class_name = "e.edit.Edit"

def openFileOnEditServer(edit_preferences_directory, filename, shouldBlock)
  begin
    File.open("#{edit_preferences_directory}/edit-server-port") { |f| f.read() =~ /^(socket|fifo):(.+)$/ }
    method = $1
    # FIXME: Why does this end in \r when the corresponding code in Terminator doesn't.
    command = "#{shouldBlock ? 'openAndBlock' : 'open'} #{filename}\r"
    if method == "socket"
      $2 =~ /^(.+):(\d+)$/
      host = $1
      port = $2.to_i()
      require "net/telnet"
      telnet = Net::Telnet.new('Host' => host, 'Port' => port, 'Telnetmode' => false)
      telnet.puts(command)
      print(telnet.readlines().join(""))
      telnet.close()
      return true
    end
    if method == "fifo"
      fifoDirectory = edit_preferences_directory
      serverFifo = $2
      pid = Process.pid()
      system("mkfifo #{fifoDirectory}/#{pid}.in")
      system("chmod 600 #{fifoDirectory}/#{pid}.in")
      system("mkfifo #{fifoDirectory}/#{pid}.out")
      system("chmod 600 #{fifoDirectory}/#{pid}.out")
      File.open("#{serverFifo}", "w") {
        |file|
        file.puts("#{pid}\n")
      }
      File.open("#{fifoDirectory}/#{pid}.in", "w") {
        |file|
        file.puts(command)
      }
      File.open("#{fifoDirectory}/#{pid}.out", "r") {
        |file|
        print(file.readlines().join(""))
      }
      system("rm -f #{fifoDirectory}/#{pid}.in")
      system("rm -f #{fifoDirectory}/#{pid}.out")
      return true
    end
  rescue
    return false
  end
end

shouldBlock = false
if ARGV[0] == "--block"
  ARGV.shift
  shouldBlock = true
end

# Translate vi/gvim line number specifications.
if ARGV[0] =~ /^\+(\d+)$/
  ARGV.shift
  ARGV[0] = "#{ARGV[0]}:#$1"
end

edit_preferences_directory = "#{HOME}/.#{edit_class_name}"
if target_os() == "Darwin"
  # Darwin is what Mac OS X calls itself.
  edit_preferences_directory = "#{ENV["HOME"]}/Library/Preferences/#{edit_class_name}"
end

if FileTest.directory?(edit_preferences_directory) == false
  puts("Edit: Couldn't find preferences directory '#{edit_preferences_directory}.")
  puts("Edit: Creating preferences directory '#{edit_preferences_directory}'.")
  Dir.mkdir(edit_preferences_directory)
end
if FileTest.exists?("#{edit_preferences_directory}/edit.properties") == false
  puts("Edit: Copying default preferences.")
  FileUtils.cp("#{project_root}/edit.properties-sample", "#{edit_preferences_directory}/edit.properties")
  FileUtils.cp("#{project_root}/edit.properties-sample", "#{edit_preferences_directory}/edit.properties.when-automatically-installed")
  puts("Edit: Away you go!")
end

filename = ARGV[0]
if filename != nil && openFileOnEditServer(edit_preferences_directory, File.expand_path(filename), shouldBlock)
  exit(0)
end

if filename != nil
  ARGV.push(filename)
end

# Try to create a FIFO which Edit can use for its InAppServer.  If this fails, it'll fall back
# to the socket method.
system("mkfifo #{edit_preferences_directory}/server-fifo")
# And let's make sure we're the only person who can access it, too.
system("chmod 600 #{edit_preferences_directory}/server-fifo")

invoker = Java.new("Edit", "e/util/Launcher")
invoker.log_filename = "/tmp/edit.log.#$$"
invoker.add_pathname_property("preferencesDirectory", edit_preferences_directory)
invoker.invoke([ "Edit", "#{edit_class_name}Launchable" ])

system("rm -f #{edit_preferences_directory}/server-fifo")
system("rm -f #{edit_preferences_directory}/edit-server-port")
