#!/usr/bin/ruby -w

require 'fileutils.rb'
require 'pathname.rb'

# Cope with symbolic links to this script.
project_root = Pathname.new("#{__FILE__}/..").realpath().dirname()
salma_hayek = Pathname.new("#{project_root}/../salma-hayek").realpath()
require "#{salma_hayek}/bin/target-os.rb"
require "#{salma_hayek}/bin/invoke-java.rb"

HOME = ENV["HOME"]
TARGET_OS = target_os()

ENV["EDIT_HOME"] = project_root
ENV["PATH"] = "#{salma_hayek}/.generated/native/all/setsid/#{TARGET_OS}:#{salma_hayek}/.generated/native/#{TARGET_OS}/BringProcessToFront/#{TARGET_OS}:#{ENV["PATH"]}"

edit_class_name = "e.edit.Edit"
edit_preferences_directory = "#{HOME}/.#{edit_class_name}"
classpath_entries = [ "#{project_root}/classes", "#{salma_hayek}/classes", "#{salma_hayek}/swing-worker.jar" ]

scm_home = Pathname.new("#{project_root}/../scm").realpath()
if FileTest.directory?(scm_home)
  classpath_entries << "#{scm_home}/classes"
end

def openFileOnEditServer(edit_preferences_directory, filename, shouldBlock)
  begin
    File.new("#{edit_preferences_directory}/edit-server-port").read() =~ /^(.+):(\d+)$/
    host = $1
    port = $2.to_i()
    require 'net/telnet'
    telnet = Net::Telnet.new('Host' => host, 'Port' => port, 'Telnetmode' => false)
    telnet.puts("#{shouldBlock ? 'open-and-block' : 'open'} #{filename}\r")
    print(telnet.readlines().join(""))
    telnet.close()
    return true
  rescue
    return false
  end
end

shouldBlock = false
if ARGV[0] == "--block"
  ARGV.shift
  shouldBlock = true
end

# Translate vi/gvim line number specifications.
if ARGV[0] =~ /^\+(\d+)$/
  ARGV.shift
  ARGV[0] = "#{ARGV[0]}:#$1"
end

os_specific_options = []
case TARGET_OS
when /Darwin/
    # Darwin is what Mac OS X calls itself.
    edit_preferences_directory = "#{ENV["HOME"]}/Library/Preferences/#{edit_class_name}"
    os_specific_options.push("-Xdock:name=Edit:icon=/Developer/Examples/Carbon/SimpleText/SimpleText.icns")
else
    classpath_entries << "#{salma_hayek}/MRJ141Stubs.jar"
end

if FileTest.directory?(edit_preferences_directory) == false
    puts("Edit: Couldn't find preferences directory '#{edit_preferences_directory}.")
    puts("Edit: Creating preferences directory '#{edit_preferences_directory}'.")
    Dir.mkdir(edit_preferences_directory)
    puts("Edit: Copying default preferences.")
    FileUtils.cp("#{project_root}/edit.properties-sample", "#{edit_preferences_directory}/edit.properties")
    FileUtils.cp("#{project_root}/edit.properties-sample", "#{edit_preferences_directory}/edit.properties.when-automatically-installed")
    puts("Edit: Away you go!")
end

filename = ARGV[0]
if filename != nil && openFileOnEditServer(edit_preferences_directory, File.expand_path(filename), shouldBlock)
  exit(0)
end

# Create a log file, and link to it as the newest.
# Symbolically linking to a file which doesn't exist yet is perfectly legal.
log_filename = "/tmp/edit.log.#$$"
FileUtils.ln_sf(log_filename, "/tmp/edit.log")

options = [ "-cp", cygpath(classpath_entries.join(":")) ]
options.push("-Djava.awt.Window.locationByPlatform=true")
options.push("-DpreferencesDirectory=#{cygpath(edit_preferences_directory)}")
options.push("-Xmx1g")
#options.push("-agentlib:yjpagent")
options.concat(os_specific_options)
if ENV["DEBUGGING_EDIT"] == nil
  options.push("-De.util.Log.filename=#{cygpath(log_filename)}")
end

args = [ "java" ]
args.concat(options)
args.push("e.util.Launcher")
args.push("Edit")
args.push("#{edit_class_name}Launchable")
args.concat(ARGV)
if filename != nil
  args.push(filename)
end
system(*args) || system("cat", log_filename)
