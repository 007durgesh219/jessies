#!/usr/bin/ruby -w

require "fileutils.rb"
require "pathname.rb"

# Cope with symbolic links to this script.
terminator_home = Pathname.new(__FILE__).realpath().dirname().dirname()
salma_hayek = Pathname.new("#{terminator_home}/../salma-hayek").realpath()

require "#{salma_hayek}/bin/target-os.rb"
require "#{salma_hayek}/bin/invoke-java.rb"
require "#{salma_hayek}/bin/which.rb"

# Make sure we have a directory for the terminal logs.
log_directory = "#{ENV['HOME']}/.terminal-logs"
if test(?d, log_directory) == false
  Dir.mkdir(log_directory)
  system("chmod", "og-rx", log_directory)
end

DISPLAY = ENV["DISPLAY"]
server_port_file = "#{log_directory}/.terminator-server-port#{DISPLAY}"

def tryInAppServer(log_directory, salma_hayek, server_port_file)
  if ENV["DEBUGGING_TERMINATOR"]
    return
  end
  # We should start a new Terminator if the client (this script) is newer than
  # the server (the currently-running Terminator). Checking just the
  # modification time of just the script is only an approximation, but it's
  # close enough for users who'll install all the files at once anyway.
  if FileUtils.uptodate?(server_port_file, [__FILE__]) == false
    return
  end
  # We only support the simple "new shell" case. Allowing the execution of
  # arbitrary commands would be a security hole. This is, as explained below,
  # simply a performance optimization.
  # This also stops existing terminals from having their options changed when
  # someone starts a new terminal.
  # It should also mean that my "runtitan" commands always block, like an xterm
  # would, rather than sometimes exiting immediately.
  workingDirectory = Dir.getwd()
  if ARGV.empty?() == false && ARGV[0] == "--working-directory"
    ARGV.shift()
    workingDirectory = ARGV.shift()
  end
  if ARGV.empty?() == false
    return
  end
  # See if there's already a Terminator running that can open us a new window.
  # This lets us emulate the Mac OS behavior when clicking on the Dock icon
  # on Linux (from gnome-panel or whatever). In particular, using this trick
  # we can open a new window quicker than xterm(1), from the user's point of
  # view.
  begin
    File.open(server_port_file) { |f| f.read() =~ /^(socket|fifo):(.+)$/ }
    method = $1
    if method == "socket"
      $2 =~ /^(.+):(\d+)$/
      # Some machines have more than one host name.
      # Fortunately, if host isn't the same machine as localhost, the connection
      # below is unlikely to work.
      host = $1
      port = $2.to_i()
      require "net/telnet"
      telnet = Net::Telnet.new('Host' => 'localhost', 'Port' => port, 'Telnetmode' => false)
      telnet.puts("newShell #{workingDirectory}")
      print(telnet.readlines().join(""))
      telnet.close()
    end
    if method == "fifo"
      serverFifo = $2
      pid = Process.pid()
      system("mkfifo #{log_directory}/#{pid}.in")
      system("chmod 600 #{log_directory}/#{pid}.in")
      system("mkfifo #{log_directory}/#{pid}.out")
      system("chmod 600 #{log_directory}/#{pid}.out")
      File.open("#{serverFifo}", "w") {
        |f|
        f.puts("#{pid}\n")
      }
      File.open("#{log_directory}/#{pid}.in", "w") {
        |f|
        f.puts("newShell #{workingDirectory}")
      }
      File.open("#{log_directory}/#{pid}.out", "r") {
        |f|
        print(f.readlines().join(""))
      }
      system("rm -f #{log_directory}/#{pid}.in")
      system("rm -f #{log_directory}/#{pid}.out")
    end
  rescue
    # We probably failed, so return and start a new process.
    return
  end

  # Job done, so finish any GNOME startup notification and exit.
  desktop_startup_id = ENV['DESKTOP_STARTUP_ID']
  if desktop_startup_id != nil
    system("#{salma_hayek}/.generated/Linux/bin/finish-gnome-startup", desktop_startup_id)
  end
  exit(0)
end

tryInAppServer(log_directory, salma_hayek, server_port_file)

launcher = "java"
if target_os() == "Cygwin"
  launcher = "#{salma_hayek}/.generated/#{target_os()}/bin/launcher"
  if ENV["DEBUGGING_TERMINATOR"] == nil
    launcher = "#{launcher}w"
  end
end

if test(?w, "/usr/share/terminfo")
  terminfo = "/usr/share/terminfo"
else
  terminfo = "#{ENV['HOME']}/.terminfo"
end
ENV["TERMINFO"] = terminfo

# rubyw.exe quits if it can't write its "Insecure world writable dir" warnings
# to $stderr every time it uses Kernel.system or Kernel.`.
if target_os() == "Cygwin" && File.exists?("/proc/self/fd/2") == false
  $stderr = File.open("/dev/null", "w")
end

tic_binary = which("tic")
terminfo_SRC = "#{terminator_home}/lib/terminfo/terminator.tic"
terminfo_DST = "#{terminfo}/t/terminator"
if test(?e, terminfo_DST) == false
  system("mkdir -p #{terminfo_DST} && rmdir #{terminfo_DST}")
end
if tic_binary != nil
  tic_command = [ tic_binary ]
  if target_os() != "Linux"
    # Debian testing/unstable's tic(1) is currently broken, and won't write an output file if asked to be verbose. All you'll get is this on stderr:
    # "/home/elliotth/Projects/terminator/lib/terminfo/terminator.tic", line 8, 'terminator' /usr/bin/tic: symbol lookup error: /usr/bin/tic: undefined symbol: _tracef
    tic_command << "-v10"
  end
  if target_os() != "SunOS"
    tic_command << "-o#{terminfo}"
  end
  tic_command << terminfo_SRC
  system(*tic_command)
elsif test(?f, terminfo_DST) == false
  system("cp", "#{terminator_home}/lib/terminfo/terminator", terminfo_DST)
end

invoker = Java.new("Terminator", "terminator/Terminator")
invoker.log_filename = "#{log_directory}/terminator.log.#{$$}"
invoker.launcher = launcher
# The "user.home" system property won't necessarily point at $HOME.
# We arranged above for $HOME/.terminal-logs/ to be available, so we need to stick to it.
# (We didn't used to be able to getenv("HOME") from Java on Cygwin.)
invoker.add_pathname_property("org.jessies.terminator.logDirectory", log_directory)

# Ruby knows the mapping from signal number to signal name, but Java doesn't
# and POSIX doesn't either. So pass the information along to Java in a way
# that won't leak through to our children.
Signal.list().each() {
  | signal_name, signal_number |
  invoker.add_property("org.jessies.terminator.signal.#{signal_number}", "SIG#{signal_name}")
}

# Try to create a FIFO which Terminator can use for its InAppServer.  If this fails, it'll fall back
# to the socket method.
system("mkfifo #{log_directory}/server-fifo")
# And let's make sure we're the only person who can access it, too.
system("chmod 600 #{log_directory}/server-fifo")

invoker.invoke()

system("rm -f #{log_directory}/server-fifo")
system("rm -f #{log_directory}/.terminator-server-port")
